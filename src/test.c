/*
 * DO NOT EDIT THIS FILE. Generated by checkmk.
 * Edit the original source file "./s21_math.h" instead.
 */

#include <check.h>

#ifndef _S21_MATH_H
#define _S21_MATH_H

#include <float.h>

#define S21_EPSILON (1e-6)
#define S21_M_PI (3.14159265358979323846264338327950288)
#define S21_E (2.71828182845904523536028747135266250)
#define S21_INFINITY (1.0 / 0.0)

double S21_NAN();         // возвращает NaN
int s21_isNan(double x);  // проверяет является ли число NaN

long int s21_abs(int x);  // вычисляет модуль целого числа
long double s21_fabs(double x);  // вычисляет модуль с плавающей точкой

long double s21_signl(double x);  // возвращает знак
int s21_isInt(long double x);  //  возвращает является ли число целым

long double s21_ceil(double x);   // округление вверх
long double s21_floor(double x);  // округление вниз

double s21_max(double x, double y);  // возвращает максимум

long double s21_exp(double x);  // возвращает e, возведенное в степень x
long double s21_pow(double base, double exp);  // возводит число в степень
long double s21_powi(double base,
                     unsigned int exp);  // возводит число в целую степень
long double s21_sqrt(double x);  // вычисляет квадратный корень

long double s21_factorial(unsigned int x);  // факториал

long double s21_fmod(double x, double y);  // остаток от деления double
long double s21_fdiv(double x, double y);

long double s21_log(double x);  // вычисляет натуральный логарифм

long double s21_acos(double x);  // вычисляет арккосинус
long double s21_asin(double x);  // вычисляет арксинус
long double s21_atan(double x);  // вычисляет арктангенс

long double s21_sin(double x);  // вычисляет синус
long double s21_cos(double x);  // вычисляет косинус
long double s21_tan(double x);  // вычисляет тангенс

#endif  // _S21_MATH_H
#include <math.h>
#include <stdio.h>
#include <stdlib.h>

#include "s21_math.h"
#include <check.h>
#include <math.h>

#include "s21_math.h"

START_TEST(s21_acos_test)
{
for (double i = -1; i <= 1; i += 0.1) {
  ck_assert_double_eq_tol(acosl(i), s21_acos(i), S21_EPSILON * 10);
}
ck_assert_ldouble_nan(s21_acos(NAN));
ck_assert_double_nan(s21_acos(INFINITY));
ck_assert_double_nan(s21_acos(-INFINITY));
#include <check.h>
#include <math.h>

#include "s21_math.h"

}
END_TEST

START_TEST(s21_asin_test)
{
for (double i = -1; i <= 1; i += 0.1) {
  ck_assert_double_eq_tol(asinl(i), s21_asin(i), S21_EPSILON);
}
ck_assert_ldouble_nan(s21_asin(NAN));
ck_assert_double_nan(s21_asin(INFINITY));
ck_assert_double_nan(s21_asin(-INFINITY));
#include <check.h>
#include <math.h>

#include "s21_math.h"

ck_assert_ldouble_eq_tol(s21_atan(42352), atan(42352), S21_EPSILON);
ck_assert_ldouble_eq_tol(s21_atan(-35363), atan(-35363), S21_EPSILON);
ck_assert_ldouble_eq_tol(s21_atan(0), atan(0), S21_EPSILON);
ck_assert_ldouble_eq_tol(s21_atan(-1), atan(-1), S21_EPSILON);
ck_assert_ldouble_eq_tol(s21_atan(1), atan(1), S21_EPSILON);
ck_assert_ldouble_eq_tol(s21_atan(0.666666), atan(0.666666), S21_EPSILON);
ck_assert_ldouble_eq_tol(s21_atan(-0.333333), atan(-0.333333), S21_EPSILON);
ck_assert_ldouble_eq_tol(s21_atan(57434.574554256), atan(57434.574554256),
                         S21_EPSILON);
ck_assert_ldouble_nan(s21_atan(NAN));
ck_assert_ldouble_eq_tol(s21_atan(INFINITY), atan(INFINITY), S21_EPSILON);
ck_assert_ldouble_eq_tol(s21_atan(-INFINITY), atan(-INFINITY), S21_EPSILON);
#include <check.h>
#include <math.h>

#include "s21_math.h"

}
END_TEST

START_TEST(s21_ceil_test)
{
for (double i = -1000; i <= 10000; i += 0.1) {
  ck_assert_double_eq_tol(ceil(i), s21_ceil(i), S21_EPSILON);
}
ck_assert_ldouble_nan(s21_ceil(NAN));
ck_assert_ldouble_eq(s21_ceil(INFINITY), ceil(INFINITY));
ck_assert_ldouble_eq(s21_ceil(-INFINITY), ceil(-INFINITY));
#include <check.h>
#include <math.h>

#include "s21_math.h"

}
END_TEST

START_TEST(s21_cos_test)
{
for (double i = -100; i <= 100; i += 0.1) {
  ck_assert_double_eq_tol(cosl(i), s21_cos(i), S21_EPSILON);
}
ck_assert_ldouble_nan(s21_cos(NAN));
ck_assert_double_nan(s21_cos(INFINITY));
ck_assert_double_nan(s21_cos(-INFINITY));
#include <check.h>
#include <math.h>

#include "s21_math.h"

}
END_TEST

START_TEST(s21_exp_test)
{
for (double i = -100; i < 30.5; i += 0.5) {
  long double sys_exp = expl(i);
  long double my_exp = s21_exp(i);
  long double eps = pow(10, log10l(sys_exp) - 16);
  if (eps < 1e-6) eps = 1e-6;
  ck_assert_ldouble_eq_tol(s21_exp(i), expl(i), eps);
}
ck_assert_ldouble_nan(s21_exp(NAN));
ck_assert_int_eq(s21_exp(INFINITY), exp(INFINITY));
ck_assert_ldouble_eq_tol(s21_exp(-INFINITY), exp(-INFINITY), S21_EPSILON);
#include <check.h>
#include <math.h>

#include "s21_math.h"

}
END_TEST

START_TEST(s21_floor_test)
{
for (double i = -1000; i <= 10000; i += 0.1) {
  ck_assert_double_eq_tol(floor(i), s21_floor(i), S21_EPSILON);
}
ck_assert_ldouble_nan(s21_floor(NAN));
ck_assert_ldouble_eq(s21_floor(INFINITY), floor(INFINITY));
ck_assert_ldouble_eq(s21_floor(-INFINITY), floor(-INFINITY));
#include <check.h>
#include <math.h>

#include "s21_math.h"

}
END_TEST

START_TEST(s21_fmod_test)
{

for (double i = 0; i <= 100000; i += S21_E) {
  ck_assert_double_eq_tol(fmod(i, 1), s21_fmod(i, 1), S21_EPSILON);
  ck_assert_double_eq_tol(fmod(-i, 1), s21_fmod(-i, 1), S21_EPSILON);
  ck_assert_double_eq_tol(fmod(i, S21_M_PI), s21_fmod(i, S21_M_PI),
                          S21_EPSILON);
  ck_assert_double_eq_tol(fmod(-i, S21_M_PI), s21_fmod(-i, S21_M_PI),
                          S21_EPSILON);
  ck_assert_double_eq_tol(fmod(i, -1), s21_fmod(i, -1), S21_EPSILON);
  ck_assert_double_eq_tol(fmod(-i, -1), s21_fmod(-i, -1), S21_EPSILON);
  ck_assert_double_eq_tol(fmod(i, -S21_M_PI), s21_fmod(i, -S21_M_PI),
                          S21_EPSILON);
  ck_assert_double_eq_tol(fmod(-i, -S21_M_PI), s21_fmod(-i, -S21_M_PI),
                          S21_EPSILON);
}
ck_assert_ldouble_nan(s21_fmod(NAN, 1));
ck_assert_double_nan(s21_fmod(INFINITY, 1));
ck_assert_double_nan(s21_fmod(-INFINITY, 1));
#include <check.h>
#include <math.h>

#include "s21_math.h"

}
END_TEST

START_TEST(s21_log_test)
{
for (double i = 0.01; i <= 1000; i += 0.1) {
  long double s21_res = s21_log(i);
  long double res = log(i);
  ck_assert_double_eq_tol(res, s21_res, S21_EPSILON);
}

}
END_TEST

START_TEST(s21_log_test_zero)
{
ck_assert_double_eq(logl(0), s21_log(0));
ck_assert_ldouble_nan(s21_log(NAN));
ck_assert_ldouble_nan(s21_log(-INFINITY));
ck_assert_ldouble_infinite(s21_log(INFINITY));
#include <check.h>
#include <math.h>

#include "s21_math.h"

}
END_TEST

START_TEST(test_s21_pow)
{
for (double i = -5; i < 5; i++) {
  for (double j = 0; j <= 10; j += 0.1) {
    long double s21_res = s21_pow(i, j);
    long double res = pow(i, j);
    long double eps = pow(10, floor(log10l(fabsl(res))) - 16);
    if (s21_isNan(res) && s21_isNan(s21_res)) {
      ck_assert_int_eq(1, 1);
    } else {
      if (eps < 1e-6) eps = 1e-6;
      ck_assert_ldouble_eq_tol(s21_res, res, eps);
    }
  }
}
ck_assert_ldouble_eq_tol(s21_pow(87.1, -INFINITY), pow(87.1, -INFINITY),
                         S21_EPSILON);
ck_assert_ldouble_eq_tol(s21_pow(0.999, INFINITY), 0, S21_EPSILON);
ck_assert_ldouble_infinite(s21_pow(14.88, INFINITY));
ck_assert_ldouble_eq_tol(s21_pow(-INFINITY, -43), pow(-INFINITY, -43),
                         S21_EPSILON);
ck_assert_ldouble_eq_tol(s21_pow(-43.23, -INFINITY), pow(-43.23, -INFINITY),
                         S21_EPSILON);
ck_assert_ldouble_eq_tol(s21_pow(-INFINITY, -43.23), pow(-INFINITY, -43.23),
                         S21_EPSILON);
#include <check.h>
#include <math.h>

#include "s21_math.h"

}
END_TEST

START_TEST(test_s21_powi)
{
for (unsigned int i = -10; i < 10; i++) {
  for (double j = 0; j < 3; j += 0.01) {
    ck_assert_ldouble_eq_tol(s21_powi(j, i), powl(j, i), S21_EPSILON);
  }
}
ck_assert_ldouble_nan(s21_powi(NAN, 1));
ck_assert_double_infinite(s21_powi(INFINITY, 1));
ck_assert_double_infinite(-1 * s21_powi(-INFINITY, 1));
#include <check.h>
#include <math.h>

#include "s21_math.h"

}
END_TEST

START_TEST(s21_sin_test)
{
for (double i = -100; i <= 100; i += 0.1) {
  ck_assert_double_eq_tol(sinl(i), s21_sin(i), S21_EPSILON);
}

ck_assert_ldouble_nan(s21_sin(NAN));
ck_assert_double_nan(s21_sin(INFINITY));
ck_assert_double_nan(s21_sin(-INFINITY));
#include <check.h>
#include <math.h>

#include "s21_math.h"

}
END_TEST

START_TEST(s21_tan_test)
{
for (double i = -100; i <= 100; i += 0.1) {
  ck_assert_double_eq_tol(tanl(i), s21_tan(i), S21_EPSILON);
}
ck_assert_ldouble_nan(s21_tan(NAN));
ck_assert_double_nan(s21_tan(INFINITY));
ck_assert_double_nan(s21_tan(-INFINITY));
#include <check.h>
#include <math.h>

#include "s21_math.h"

}
END_TEST

START_TEST(abs_test)
{
int x = -25;
ck_assert_uint_eq(s21_abs(x), abs(x));
x = 25;
ck_assert_uint_eq(s21_abs(x), abs(x));
#include <check.h>
#include <math.h>

#include "s21_math.h"

}
END_TEST

START_TEST(fabs_test)
{
int x = -25;
ck_assert_uint_eq(s21_fabs(x), fabs(x));
x = 25;
ck_assert_uint_eq(s21_fabs(x), fabs(x));

ck_assert_ldouble_nan(s21_fabs(NAN));
ck_assert_double_infinite(s21_fabs(INFINITY));
ck_assert_double_infinite(s21_fabs(-INFINITY));
#include <check.h>
#include <math.h>

#include "s21_math.h"

}
END_TEST

START_TEST(sqrt_test)
{
for (int i = 0; i < 100; i++) {
  ck_assert_double_eq_tol(s21_sqrt(i), sqrt(i), S21_EPSILON);
}
ck_assert_ldouble_nan(s21_sqrt(NAN));
ck_assert_double_infinite(s21_sqrt(INFINITY));
ck_assert_double_nan(s21_sqrt(-INFINITY));
}
END_TEST

int main(void)
{
    Suite *s1 = suite_create("Core");
    TCase *tc1_1 = tcase_create("Core");
    SRunner *sr = srunner_create(s1);
    int nf;

    suite_add_tcase(s1, tc1_1);
    tcase_add_test(tc1_1, s21_acos_test);
    tcase_add_test(tc1_1, s21_asin_test);
    tcase_add_test(tc1_1, s21_ceil_test);
    tcase_add_test(tc1_1, s21_cos_test);
    tcase_add_test(tc1_1, s21_exp_test);
    tcase_add_test(tc1_1, s21_floor_test);
    tcase_add_test(tc1_1, s21_fmod_test);
    tcase_add_test(tc1_1, s21_log_test);
    tcase_add_test(tc1_1, s21_log_test_zero);
    tcase_add_test(tc1_1, test_s21_pow);
    tcase_add_test(tc1_1, test_s21_powi);
    tcase_add_test(tc1_1, s21_sin_test);
    tcase_add_test(tc1_1, s21_tan_test);
    tcase_add_test(tc1_1, abs_test);
    tcase_add_test(tc1_1, fabs_test);
    tcase_add_test(tc1_1, sqrt_test);

    srunner_run_all(sr, CK_ENV);
    nf = srunner_ntests_failed(sr);
    srunner_free(sr);

    return nf == 0 ? 0 : 1;
}
